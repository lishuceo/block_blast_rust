<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>方块消除游戏</title>
    <style>
        /* Basic Reset & Debug Base Styles */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%; /* Ensure body takes full height for percentage children */
            overflow: hidden; /* Prevent accidental scrollbars */
            position: fixed; /* Prevent iOS Safari scroll bouncing */
            top: 0; left: 0; right: 0; bottom: 0;
            background: #3C569E; /* Base background */
            -webkit-touch-callout: none; /* Disable iOS callouts */
            -webkit-user-select: none; /* Disable selection */
            user-select: none;
            /* Debug Borders */
            border: 3px solid red !important; /* HTML */
            box-sizing: border-box;
        }
        body {
            border: 3px solid blue !important; /* Body */
            box-sizing: border-box;
        }

        /* Game Wrapper: Full screen, centers content, handles safe area */
        .game-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* padding-top: env(safe-area-inset-top, 0px);
            padding-right: env(safe-area-inset-right, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
            padding-left: env(safe-area-inset-left, 0px); */
            box-sizing: border-box; /* Include padding in size */
            /* Debug Borders */
            border: 3px solid green !important;
            /*background-color: rgba(0, 255, 0, 0.1);  Light green background for wrapper */
        }

        /* Game Container: Fills height, adapts width, max aspect ratio 2:3 */
        .game-container {
            height: 100%; /* Fill the flex-item height */
            width: 100%; /* Try to fill width */
            /* Set max-width based on height (100vh) and max 2:3 aspect ratio */
            max-width: calc(100vh * (2 / 3)); 
            /* max-width: 100%; */ /* <-- 移除或注释掉之前的 max-width: 100% */
            position: relative; /* For canvas positioning */
            overflow: hidden;
            /* background: black; */
             /* Debug Borders */
            border: 3px solid yellow !important;
            /* background-color: rgba(255, 255, 0, 0.1); */
        }

        /* Canvas: Fills the container */
        #glcanvas {
            display: block; /* Remove potential inline spacing issues */
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
             /* Debug Borders */
            border: 3px solid magenta !important;
            box-sizing: border-box;
        }

        /* --- DEBUG OVERLAY --- */
        #debug-overlay {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0px); /* Position above safe area */
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: monospace;
            font-size: 10px;
            padding: 5px env(safe-area-inset-right, 5px) 5px env(safe-area-inset-left, 5px);
            z-index: 9999;
            pointer-events: none; /* Allow clicks to pass through */
            white-space: pre-wrap; /* Preserve line breaks */
            max-height: 30vh; /* Limit height */
            overflow-y: auto; /* Allow scrolling if needed */
            border-top: 1px solid cyan;
        }
        /* --- END DEBUG OVERLAY --- */

         /* --- DEBUG SAFE AREA VISUALIZATION --- REMOVED as padding handles it */
         /* #safe-area-vis { ... } */
         /* --- END DEBUG SAFE AREA VISUALIZATION --- */
       
    </style>
    <!-- 确保在任何其他脚本前加载尺寸修复工具 - REMOVED -->
    <!-- <script src="canvas_fixer.js"></script> -->
    
    <!-- 添加SCE SDK (需要先加载) -->
    <script src="https://cdn.jsdelivr.net/npm/sce-game-sdk@1.0.2/dist/sce.min.js"></script>
</head>

<body>
    <!-- 添加一个额外的包装容器 -->
    <div class="game-wrapper">
        <!-- 游戏容器 -->
        <div class="game-container">
            <!-- 画布 -->
            <canvas id="glcanvas" tabindex='1'></canvas>
        </div>
    </div>
    
    <!-- Debug Info Overlay -->
    <div id="debug-overlay">Loading debug info...</div>
    <!-- Safe Area Visualization - Removed -->
    <!-- <div id="safe-area-vis"></div> -->
    
    <!-- 将脚本移到body末尾以确保DOM加载完成 -->
    <!-- 加载macroquad的JavaScript -->
    <script src="mq_js_bundle.js"></script>
    <!-- 添加JavaScript桥接代码（放在mq_js_bundle.js之后） -->
    <script src="js_bridge.js"></script>
    <!-- 添加测试脚本 -->
    <script src="test_messages.js"></script>
    
    <!-- 内联脚本也移到最后 -->
    <script>
        // --- SCE SDK Configuration and Functions ---
        window.SCE_CONFIG = {
            developer_token: 'db2c71a6-ed95-4fe7-a2ba-dfa2f6fd78b0',
            env: 'pd'
        };
        // 初始化SDK的辅助函数
        window.sce_init_sdk = function(token, env) {
            console.log("sce_init_sdk called with token:", token, "and env:", env);
            // 检查SceSDK对象是否存在
            if (typeof SceSDK === 'undefined' || SceSDK === null) {
                const errorMsg = "SCE SDK尚未加载或初始化失败";
                console.error(errorMsg);
                return JSON.stringify({success: false, message: errorMsg});
            }
            
            try {
                SceSDK.init({
                    sce_developer_token: token,
                    env: env || 'pd'
                });
                console.log("SCE SDK 初始化成功");
                return JSON.stringify({success: true});
            } catch (error) {
                console.error("SCE SDK初始化失败:", error);
                return JSON.stringify({success: false, message: error.toString()});
            }
        };
        
        // 登录辅助函数
        window.sce_login = async function() {
            try {
                await SceSDK.login();
                const userInfo = SceSDK.get_user_info();
                return JSON.stringify({
                    success: true,
                    user_id: userInfo.user_id,
                    name: userInfo.name
                });
            } catch (error) {
                console.error("SCE SDK登录失败:", error);
                return JSON.stringify({success: false, message: error.toString()});
            }
        };
        
        // 上传分数
        window.sce_upload_score = async function(score) {
            try {
                const res = await SceSDK.cloud.set_number('player_score', score);
                const result = await res.json();
                return JSON.stringify({success: result.code === 0});
            } catch (error) {
                console.error("上传分数失败:", error);
                return JSON.stringify({success: false, message: error.toString()});
            }
        };
        
        // 获取排行榜
        window.sce_get_leaderboard = async function(limit) {
            console.log("call sce_get_leaderboard");
            try {
                const res = await SceSDK.cloud.get_top_rank('player_score', limit || 10, false, 'desc');
                const result = await res.json();
                console.log("获取排行榜成功:", result);
                return JSON.stringify({
                    success: result.code === 0,
                    data: result.rows || []
                });
            } catch (error) {
                console.error("获取排行榜失败:", error);
                return JSON.stringify({success: false, message: error.toString()});
            }
        };
        
        // 获取用户排名
        window.sce_get_user_rank = async function() {
            try {
                const res = await SceSDK.cloud.get_user_rank('player_score');
                const result = await res.json();
                return JSON.stringify({
                    success: result.code === 0,
                    rank: result.rank,
                    score: result.value,
                    user_id: result.user_id
                });
            } catch (error) {
                console.error("获取用户排名失败:", error);
                return JSON.stringify({success: false, message: error.toString()});
            }
        };
        
        // 检测WebAssembly JIT状态
        window.checkWasmJitEnabled = function() {
            // 尝试检测Wasm是否可用和JIT状态
            let jitStatus = "Unknown";
            
            // 检测WebAssembly基本支持
            if (typeof WebAssembly === 'object') {
                jitStatus = "Basic Support";
                
                // 检测一些高级特性可能表明JIT已启用
                // 注意：浏览器不直接暴露JIT状态，这只是一个近似检测
                if (WebAssembly.validate && WebAssembly.compile && WebAssembly.instantiate) {
                    // 检测是否有流式编译支持（通常表示有JIT）
                    if (typeof WebAssembly.instantiateStreaming === 'function') {
                        jitStatus = "JIT Possible";
                        
                        // 进一步检测是否有SharedArrayBuffer和Atomics支持
                        // 这些特性通常与高性能Wasm执行环境相关
                        if (typeof SharedArrayBuffer === 'function' && typeof Atomics === 'object') {
                            jitStatus = "JIT Enabled";
                        }
                    }
                }
            } else {
                jitStatus = "Not Supported";
            }
            
            // 将状态存储在全局变量中，以便Rust代码通过FFI访问
            window.wasmJitStatus = jitStatus;
            
            // 返回状态字符串
            return jitStatus;
        };
        
        // 在加载页面时立即检测
        window.wasmJitStatus = window.checkWasmJitEnabled();
        
        // 为Rust代码提供获取JIT状态的函数
        window.getWasmJitStatus = function() {
            return window.wasmJitStatus || "Unknown";
        };
        // --- END SCE SDK ---

        // 加载WASM - User Added Code
        try {
            if (typeof load === 'function') {
                 load("block_blast_bin.wasm");
                 console.log("WASM加载成功");
            } else {
                 console.error("'load' function not found. WASM might not load correctly.");
            }
        } catch(e) {
            console.error("加载WASM出错:", e);
            alert("游戏加载失败，请刷新页面或检查控制台错误信息");
        }
        // --- END User Added Code ---

        // --- Simplified Resize Handler & Debug Info (v5 - Renamed Variable) ---
        // Declare variables ONCE here using the new name
        const gameCanvasElement = document.getElementById('glcanvas'); // RENAMED from canvas
        const gameContainer = document.querySelector('.game-container');
        const gameWrapper = document.querySelector('.game-wrapper');
        const debugOverlay = document.getElementById('debug-overlay');

        function updateDebugInfo() {
            // Use the new variable name 'gameCanvasElement'
            if (!debugOverlay || !gameCanvasElement || !gameContainer || !gameWrapper) return;

            const html = document.documentElement;
            const body = document.body;
            let safeAreaBottom = "N/A";
            try {
                 safeAreaBottom = getComputedStyle(gameWrapper).paddingBottom || "N/A";
            } catch(e) { console.warn("Could not get wrapper paddingBottom"); }

            const info = `
                Window: ${window.innerWidth}w x ${window.innerHeight}h
                HTML client: ${html.clientWidth}w x ${html.clientHeight}h
                Body client: ${body.clientWidth}w x ${body.clientHeight}h
                Wrapper client: ${gameWrapper.clientWidth}w x ${gameWrapper.clientHeight}h (padding: ${getComputedStyle(gameWrapper).padding})
                Container client: ${gameContainer.clientWidth}w x ${gameContainer.clientHeight}h
                Canvas client: ${gameCanvasElement.clientWidth}w x ${gameCanvasElement.clientHeight}h
                Canvas offset: ${gameCanvasElement.offsetWidth}w x ${gameCanvasElement.offsetHeight}h
                Canvas style: ${gameCanvasElement.style.width || 'auto'}w x ${gameCanvasElement.style.height || 'auto'}h
                Canvas attr: ${gameCanvasElement.getAttribute('width')}w x ${gameCanvasElement.getAttribute('height')}h
                DevicePixelRatio: ${window.devicePixelRatio}
                SafeAreaBottom (Padding): ${safeAreaBottom}
                Screen: ${window.screen.width} x ${window.screen.height} (avail: ${window.screen.availWidth} x ${window.screen.availHeight})
                User Agent: ${navigator.userAgent}
            `;
            debugOverlay.textContent = info.trim();
        }

        function resizeHandler() {
            // Use the new variable name 'gameCanvasElement'
            if (!gameCanvasElement) return;
            console.log("Resize event triggered - Simple Handler");

            const rect = gameCanvasElement.getBoundingClientRect();
            const cssWidth = rect.width;
            const cssHeight = rect.height;
            const dpr = window.devicePixelRatio || 1;

            if (cssWidth > 0 && cssHeight > 0) {
                gameCanvasElement.width = Math.round(cssWidth * dpr); // Use new name
                gameCanvasElement.height = Math.round(cssHeight * dpr); // Use new name
                console.log(`Canvas resized: CSS=${cssWidth}x${cssHeight}, Attr=${gameCanvasElement.width}x${gameCanvasElement.height}, DPR=${dpr}`);
            } else {
                console.warn("Resize handler: Invalid CSS dimensions detected.", cssWidth, cssHeight);
            }

            updateDebugInfo();

            if (typeof window.miniquad_update_canvas_size === 'function') {
                window.miniquad_update_canvas_size();
                console.log("Called miniquad_update_canvas_size()");
            }
        }

        // Initial setup
        window.addEventListener('load', () => {
            // No declarations here
            console.log("Page loaded - Simple Setup");
            setTimeout(() => {
                 resizeHandler();
                 updateDebugInfo();
            }, 100);

            setInterval(updateDebugInfo, 1000);

            // iOS specific fixes
            document.addEventListener('gesturestart', function(e) { e.preventDefault(); return false; });
            document.addEventListener('touchmove', function(e) { if (e.touches.length > 1) { e.preventDefault(); } }, { passive: false });
            function isIOS() { return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); }
            if (isIOS()) {
                 console.log("iOS detected - applying fixes...");
                 // ... (Assume full iOS fixes like preventing double-tap zoom, etc.)
            }
        });

        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', resizeHandler);
        // --- END Simple Resize ---

    </script>
</body>

</html>